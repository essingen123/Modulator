// ------------------------- The LiveCoding API ------------------------------

interface LiveCoding {
	/** The AudioContext, for the daring ones */
	context: AudioContext
	/** Creates an instrument from a preset name, number or data */
	instrument(preset: number | string | PresetData, name?: string, numVoices?: number): Instrument
	/** Creates an effect */
	effect(name: string, newName?: string): Effect
	/** Creates a named track */
	track(name: string, cb?: TrackCallback): Track
	/** Creates a looping track */
	loop_track(name: string, cb?: TrackCallback): Track
	/** Enables or disables logging of note events */
	use_log(enable?: boolean): this
	/** Prints the specified data to the log */
	log(...args: any[]): this
	/** Change global BPM */
	bpm(value?: number): number | this
	/** Stops all looping track at the end of their loop */
	stop(): this
	/** Pauses all tracks at their current position */
	pause(): this
	/** Continues playback of stopped or paused tracks */
	continue(): this
	/** Stops and deletes all tracks */
	reset(): this
}


// -------------------- Instruments, effects and tracks -------------------------

interface Instrument {
	/** Name of the preset used to create the instrument */
	name: string
	/** Default note duration, in seconds */
	duration: number
	/** Gets or sets the value of a parameter */
	param(pname: string, value?: number): number | this
	/** Returns a list of parameter names */
	paramNames(): string[]
}

/** Effects allow altering the sound output generated by a track */
interface Effect {
	/** Effect name */
	name: string
	/** Gets or sets the value of a parameter */
	param(name: string, value?: number, rampTime?: number, exponential?: boolean): number | this
	/** Returns a list of parameter names */
	paramNames(): string[]
}

type TrackCallback = (t: Track) => void

interface InstrumentOptions {
	instrument: Instrument
	[k: string]: number | Instrument
}

interface EffectOptions {
	effect: Effect
	[k: string]: number | Effect
}

type NoteOptions = InstrumentOptions | EffectOptions

interface PresetData {
	name: string
	nodes: any[]
	nodeData: any[]
	modulatorType: string
}

/** The TrackControl interface provides access to a playing track in order
to control its general status, such as muting, pausing, adding an effect, etc. */
interface TrackControl {
	/** Adds an effect to the track. All sound played in the track will be
	altered by the effect */
	effect(e: Effect): this
	/** Mutes track audio */
	mute(): this
	/** Unmutes track */
	unmute(): this
	/** Sets global gain for all notes */
	gain(value: number, rampTime?: number): this
	/** Stops a looping track at the end of the loop */
	stop(): this
	/** Pauses a track at its current position */
	pause(): this
	/** Continues playback of a stopped or paused track */
	continue(): this
	/** Stops and deletes the track from the tracks object */
	delete(): void
}

/** The Track interface provides access to time-based functions
 such as playing notes, waiting for a specified time, etc. */
interface Track {
	/** For looping tracks, counts how many times the loop has executed */
	loopCount: number
	/** Sets the instrument to play in the track */
	instrument(inst: Instrument): this
	/** Adds an effect to the track. All sound played in the track will be
	immediately altered by the effect */
	effect(e: Effect): this
	/** Sets the volume to use in the track */
	volume(v: number): this
	/** Plays a given note */
	play(note: number, duration?: number, options?: NoteOptions): this
	/** Transposes notes the specified amount */
	transpose(notes: number): this
	/** Changes a parameter of the current instrument */
	param(pname: string, value: number): this
	/** Changes parameters of instrument or effect */
	params(options: NoteOptions): this
	/** Waits the specified time in seconds before playing the next note */
	sleep(time: number): this
	/** Repeats the enclosed code a given number of times */
	repeat(times: number, cb: (i: number) => void): void
}


// -------------------- Globals -------------------------

interface InstrumentTable {
	[instrName: string]: Instrument
}

interface EffectTable {
	[effectName: string]: Effect
}

interface TrackTable {
	[trackName: string]: TrackControl
}

/** Holds all instruments created by lc.instrument() */
declare let instruments: InstrumentTable

/** Holds all effects created by lc.effect() */
declare let effects: EffectTable

/** Holds all tracks created by lc.track() or lc.loop_track() */
declare let tracks: TrackTable

/** A global area to store any data to be used across executions */
declare let global: any

/** The live coding API entry point, used to create instruments,
 effects and tracks, and controlling global settings */
declare let lc: LiveCoding


// -------------------- Rings -------------------------

/** A ring is an array extended with immutable operations and a convenient
tick() iterator */
interface Ring<T> extends Array<T> {
	/** Returns the current element and increments the position counter.
	If the position counter goes past the end of the ring, it wraps to
	the start of the ring */
	tick(): T
	/** Creates a copy of the ring */
	clone(): Ring<T>
	/** Returns a reversed copy of the ring */
	reverse(): Ring<T>
	/** Returns a shuffled copy of the ring */
	shuffle(): Ring<T>
	/** Returns a new ring containing only the first **n** elements */
	take(n: number): Ring<T>
	/** Returns a new ring containing everything but the first **n** elements */
	drop(n: number): Ring<T>
	/** Returns a new ring with the last element missing  */
	butlast(): Ring<T>
	/** Returns a new ring with the last **n** elements missing */
	drop_last(n: number): Ring<T>
	/** Returns a new ring with only the last **n** elements */
	take_last(n: number): Ring<T>
	/** Repeats each element in the ring **n** times */
	stretch(n: number): Ring<T>
	/** Repeats the entire ring **n** times */
	repeat(n: number): Ring<T>
	/** Adds the ring to a reversed version of itself  */
	mirror(): Ring<T>
	/** Adds the ring to a reversed version of itself,
	without duplicating the middle value  */
	reflect(): Ring<T>
	/** Returns a new ring with all elements multiplied by **n**
	(assumes ring contains numbers only) */
	scale(n: number): Ring<T>
	/** Returns a new ring with **n** added to all elements
	(assumes ring contains numbers only) */
	transpose(n: number): Ring<T>
}

interface Array<T> {
	/** Creates a ring from an array */
	ring: () => Ring<T>
}
